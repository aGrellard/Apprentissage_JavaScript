{
    "QCM" : [
      {
        "title": "Trouver le premier élément supérieur à 10",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 1,
        "question_type": "code_analysis",
        "question_text": "Quel est le résultat de l'opération `find` dans ce code ?",
        "snippet": {
          "html": "",
          "javascript": "let numbers = [5, 12, 8, 130, 44];\nlet found = numbers.find(element => element > 10);"
        },
        "options": {
          "A": "12",
          "B": "[12, 130, 44]",
          "C": "130",
          "D": "undefined"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `find` retourne la valeur du premier élément dans le tableau qui satisfait la fonction de test fournie. Ici, elle retourne `12`, le premier élément supérieur à 10."
      },
      {
        "title": "Application de `map` pour transformer un tableau",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 2,
        "question_type": "code_analysis",
        "question_text": "Quel tableau est produit après l'application de la méthode `map` ?",
        "snippet": {
          "html": "",
          "javascript": "let numbers = [1, 4, 9];\nlet roots = numbers.map(Math.sqrt);"
        },
        "options": {
          "A": "[1, 2, 3]",
          "B": "[1, 16, 81]",
          "C": "[0, 2, 3]",
          "D": "[1, 4, 9]"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `map` crée un nouveau tableau avec les résultats de l'appel d'une fonction fournie sur chaque élément du tableau appelant. Ici, elle retourne un nouveau tableau avec les racines carrées de chaque élément, donc `[1, 2, 3]`."
      },
      {
        "title": "Application de `map` pour transformer un tableau",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 2,
        "question_type": "code_analysis",
        "question_text": "Quel tableau est produit après l'application de la méthode `map` ?",
        "snippet": {
          "html": "",
          "javascript": "let numbers = [1, 4, 9];\nlet roots = numbers.map(Math.sqrt);"
        },
        "options": {
          "A": "[1, 2, 3]",
          "B": "[1, 16, 81]",
          "C": "[0, 2, 3]",
          "D": "[1, 4, 9]"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `map` crée un nouveau tableau avec les résultats de l'appel d'une fonction fournie sur chaque élément du tableau appelant. Ici, elle retourne un nouveau tableau avec les racines carrées de chaque élément, donc `[1, 2, 3]`."
      },
      {
        "title": "Filtrage d'un tableau d'objets",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 3,
        "question_type": "code_analysis",
        "question_text": "Quel tableau est produit après l'application de la méthode `filter` ?",
        "snippet": {
          "html": "",
          "javascript": "let products = [\n  { name: 'Apple', type: 'fruit' },\n  { name: 'Monitor', type: 'electronics' },\n  { name: 'Carrot', type: 'vegetable' }\n];\nlet fruits = products.filter(product => product.type === 'fruit');"
        },
        "options": {
          "A": "[{ name: 'Apple', type: 'fruit' }]",
          "B": "[{ name: 'Monitor', type: 'electronics' }]",
          "C": "[{ name: 'Carrot', type: 'vegetable' }]",
          "D": "[]"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `filter` crée un nouveau tableau avec tous les éléments qui passent le test implémenté par la fonction fournie. Ici, elle retourne un tableau contenant uniquement l'objet avec `type: 'fruit'`."
      },
      {
        "title": "Concaténation de tableaux",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 4,
        "question_type": "code_analysis",
        "question_text": "Quel est le résultat de l'opération `concat` dans ce code ?",
        "snippet": {
          "html": "",
          "javascript": "let array1 = ['a', 'b', 'c'];\nlet array2 = ['d', 'e', 'f'];\nlet combined = array1.concat(array2);"
        },
        "options": {
          "A": "['a', 'b', 'c', 'd', 'e', 'f']",
          "B": "['d', 'e', 'f', 'a', 'b', 'c']",
          "C": "[['a', 'b', 'c'], ['d', 'e', 'f']]",
          "D": "['a', 'b', 'c']"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `concat` est utilisée pour fusionner deux ou plusieurs tableaux. Ce processus ne change pas les tableaux existants, mais retourne un nouveau tableau. Ici, `combined` contient `['a', 'b', 'c', 'd', 'e', 'f']`."
      },
      {
        "title": "Utilisation de `every` pour tester les éléments d'un tableau",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 5,
        "question_type": "code_analysis",
        "question_text": "Le tableau satisfait-il la condition donnée par `every` ?",
        "snippet": {
          "html": "",
          "javascript": "let ages = [32, 33, 16, 40];\nlet checkAge = ages.every(age => age >= 18);"
        },
        "options": {
          "A": "true",
          "B": "false",
          "C": "undefined",
          "D": "Error"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `every` teste si tous les éléments du tableau passent le test implémenté par la fonction fournie. Ici, puisque tous les âges sont supérieurs ou égaux à 18, `checkAge` vaut `true`."
      },
      {
        "title": "Réduction d'un tableau d'objets",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 6,
        "question_type": "code_analysis",
        "question_text": "Quelle est la valeur totale des quantités dans ce tableau d'objets ?",
        "snippet": {
          "html": "",
          "javascript": "let items = [\n  { name: 'Pen', quantity: 10 },\n  { name: 'Notebook', quantity: 5 },\n  { name: 'Eraser', quantity: 7 }\n];\nlet totalQuantity = items.reduce((total, item) => total + item.quantity, 0);"
        },
        "options": {
          "A": "22",
          "B": "3",
          "C": "0",
          "D": "12"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `reduce` applique une fonction qui est un « accumulateur » qui traite chaque valeur d'un tableau pour la réduire à une seule valeur. En partant de 0, elle additionne les quantités de chaque objet, donnant un total de 22."
      },
      {
        "title": "Transformation d'un tableau en objet",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 7,
        "question_type": "code_analysis",
        "question_text": "Quel est le résultat de l'opération `reduce` pour transformer un tableau en objet ?",
        "snippet": {
          "html": "",
          "javascript": "let keyValueArray = [['key1', 'value1'], ['key2', 'value2']];\nlet resultObject = keyValueArray.reduce((obj, [key, value]) => {\n  obj[key] = value;\n  return obj;\n}, {});"
        },
        "options": {
          "A": "{ 'key1': 'value1', 'key2': 'value2' }",
          "B": "[['key1', 'value1'], ['key2', 'value2']]",
          "C": "{}",
          "D": "Error"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `reduce` ici est utilisée pour transformer un tableau de tableaux clé-valeur en un objet. Le deuxième argument de `reduce` (`{}`) est la valeur initiale pour l'objet résultant. Ainsi, `resultObject` devient `{ 'key1': 'value1', 'key2': 'value2' }`."
      },
      {
        "title": "Tri d'un tableau d'objets",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 8,
        "question_type": "code_analysis",
        "question_text": "Comment sont triés les objets dans le tableau après l'application de `sort` ?",
        "snippet": {
          "html": "",
          "javascript": "let items = [\n  { name: 'Banana', quantity: 2 },\n  { name: 'Apple', quantity: 10 },\n  { name: 'Orange', quantity: 5 }\n];\nitems.sort((a, b) => a.quantity - b.quantity);"
        },
        "options": {
          "A": "Par quantité, en ordre croissant",
          "B": "Par quantité, en ordre décroissant",
          "C": "Par nom, en ordre alphabétique",
          "D": "Aucun tri n'est appliqué"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `sort` trie les éléments d'un tableau en place et retourne le tableau. La fonction de comparaison ici compare les quantités, donc les objets sont triés par quantité en ordre croissant."
      },
      {
        "title": "Trouver l'indice d'un élément dans un tableau",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 9,
        "question_type": "code_analysis",
        "question_text": "Quel est l'indice de l'élément 'Banana' dans le tableau ?",
        "snippet": {
          "html": "",
          "javascript": "let fruits = ['Apple', 'Banana', 'Cherry'];\nlet index = fruits.indexOf('Banana');"
        },
        "options": {
          "A": "1",
          "B": "2",
          "C": "0",
          "D": "-1"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `indexOf` retourne le premier indice auquel un élément donné peut être trouvé dans le tableau, ou -1 si l'élément n'est pas présent. L'indice de 'Banana' dans le tableau est 1."
      },
      {
        "title": "Utilisation de `slice` pour extraire une partie d'un tableau",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 10,
        "question_type": "code_analysis",
        "question_text": "Quel est le résultat de l'opération `slice` dans ce code ?",
        "snippet": {
          "html": "",
          "javascript": "let numbers = [1, 2, 3, 4, 5];\nlet sliced = numbers.slice(1, 4);"
        },
        "options": {
          "A": "[2, 3, 4]",
          "B": "[1, 2, 3, 4]",
          "C": "[2, 3, 4, 5]",
          "D": "[3, 4]"
        },
        "correct_answer": {
          "answer": ["A"]
        },
        "explanation": "La méthode `slice` retourne une copie superficielle d'une portion d'un tableau dans un nouveau tableau objet sélectionné de `start` à `end` (end non compris). Ici, `sliced` contient `[2, 3, 4]`."
      },
      {
        "title": "Combinaisons de méthodes sur les tableaux",
        "category": "Les Méthodes sur les Tableaux",
        "question_number": 11,
        "question_type": "code_analysis",
        "question_text": "Quelles affirmations sont vraies concernant le code suivant ?",
        "snippet": {
          "html": "",
          "javascript": "let numbers = [1, 2, 3, 4];\nlet processed = numbers.map(x => x * 2).filter(x => x > 5);"
        },
        "options": {
          "A": "Le résultat final `processed` est `[6, 8]`",
          "B": "`map` est appliqué avant `filter`",
          "C": "Le résultat de `map` seul serait `[2, 4, 6, 8]`",
          "D": "`filter` élimine tous les éléments inférieurs à 5",
          "E": "Le code génère une erreur"
        },
        "correct_answer": {
          "answer": ["A", "B", "C", "D"]
        },
        "explanation": "Ce code utilise d'abord `map` pour doubler chaque élément du tableau, produisant `[2, 4, 6, 8]`. Ensuite, `filter` est appliqué pour éliminer les éléments inférieurs ou égaux à 5, laissant `[6, 8]` comme résultat final dans `processed`. Aucune erreur n'est générée."
      },
      {
        "title": "Déclaration de variables et hoisting",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 1,
        "question_type": "code_analysis",
        "question_text": "Quelle est la valeur affichée dans la console ?",
        "snippet": {
          "html":"",
          "javascript": "console.log(x);\nvar x = 5;"
        },
        "options": {
          "A": "\"5\"",
          "B": "\"undefined\"",
          "C": "Erreur de référence",
          "D": "null"
        },
        "correct_answer": {
          "answer": ["B"]
        },
        "explanation": "En raison du hoisting, la déclaration de `var x = 5;` est hissée au sommet de son contexte d'exécution (mais pas son initialisation). Cela signifie que lors de l'exécution de `console.log(x);`, `x` est déjà déclaré mais non initialisé, affichant donc `undefined`."
      },
      {
        "title": "Portée des variables déclarées avec `let`",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 2,
        "question_type": "code_analysis",
        "question_text": "Quelle est la valeur affichée dans la console ?",
        "snippet": {
          "html":"",
          "javascript": "let x = 10;\nfunction test() {\n  let x = 20;\n  console.log(x);\n}\ntest();"
        },
        "options": {
          "A": "10",
          "B": "20",
          "C": "undefined",
          "D": "Erreur"
        },
        "correct_answer": {
          "answer": ["B"]
        },
        "explanation": "La variable `x` déclarée dans la fonction `test` avec `let` a une portée de bloc, ce qui signifie qu'elle est locale à la fonction `test`. Ainsi, `console.log(x);` dans `test` affiche `20`, la valeur de la variable locale."
      },
      {
        "title": "Mutabilité des objets",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 3,
        "question_type": "code_analysis",
        "question_text": "Quel est l'état final de l'objet `person` ?",
        "snippet": {
          "html":"",
          "javascript": "const person = { name: 'Alex' };\nperson.age = 30;\nperson.name = 'Bob';"
        },
        "options": {
          "A": "{ name: 'Alex', age: 30 }",
          "B": "{ name: 'Bob', age: 30 }",
          "C": "Erreur",
          "D": "{ name: 'Bob' }"
        },
        "correct_answer": {
          "answer": ["B"]
        },
        "explanation": "Les objets déclarés avec `const` sont mutables. Cela signifie que, bien que l'assignation directe à `person` (par exemple, `person = {}`) générerait une erreur, modifier les propriétés de `person` est parfaitement valide. L'objet `person` final est donc `{ name: 'Bob', age: 30 }`."
      },
      {
        "title": "Comparaison de types et de valeurs",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 4,
        "question_type": "code_analysis",
        "question_text": "Quelle assertion est vraie concernant les opérateurs de comparaison suivants ?",
        "snippet": {
          "html":"",
          "javascript": "\"5\" == 5;\n\"5\" === 5;"
        },
        "options": {
          "A": "Les deux comparaisons retournent `true`.",
          "B": "La première comparaison retourne `true`, la seconde `false`.",
          "C": "La première comparaison retourne `false`, la seconde `true`.",
          "D": "Les deux comparaisons retournent `false`."
        },
        "correct_answer": {
          "answer": ["B"]
        },
        "explanation": "En JavaScript, `==` compare les valeurs après avoir effectué une conversion de type (coercition), tandis que `===` compare à la fois les valeurs et les types sans conversion. Donc, `\"5\" == 5` est vrai (après conversion), mais `\"5\" === 5` est faux (car les types sont différents)."
      },
      {
        "title": "Portée des variables avec `var` dans une boucle",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 5,
        "question_type": "code_analysis",
        "question_text": "Quelle est la valeur de `i` après l'exécution de la boucle ?",
        "snippet": {
          "html":"",
          "javascript": "for (var i = 0; i < 5; i++) {\n  // do something\n}\nconsole.log(i);"
        },
        "options": {
          "A": "4",
          "B": "5",
          "C": "undefined",
          "D": "Erreur"
        },
        "correct_answer": {
          "answer": ["B"]
        },
        "explanation": "Les variables déclarées avec `var` ont une portée de fonction ou sont globales si elles ne sont pas dans une fonction. Dans ce cas, `i` est accessible en dehors de la boucle for et sa valeur finale sera `5` après la fin de la boucle."
      },
      {
        "title": "Effet de l'utilisation de `const` pour déclarer des tableaux",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 6,
        "question_type": "code_analysis",
        "question_text": "Quelles opérations sont permises sur le tableau `numbers` déclaré avec `const` ?",
        "snippet": {
          "html": "",
          "javascript": "const numbers = [1, 2, 3];\nnumbers.push(4);\nnumbers = [5, 6, 7];"
        },
        "options": {
          "A": "Ajouter un élément avec `push`",
          "B": "Réaffecter avec un nouveau tableau",
          "C": "Modifier un élément existant",
          "D": "Toutes les opérations ci-dessus"
        },
        "correct_answer": {
          "answer": ["A", "C"]
        },
        "explanation": "Avec `const`, vous pouvez modifier un tableau existant (par exemple, ajouter ou modifier des éléments) car la référence à l'objet tableau ne change pas. Cependant, réaffecter `numbers` à un nouveau tableau lève une erreur car `const` interdit de réassigner la variable."
      },
      {
        "title": "Utilisation de `let` dans les blocs de code",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 7,
        "question_type": "code_analysis",
        "question_text": "Quelle est la portée de `x` déclarée avec `let` dans ce code ?",
        "snippet": {
          "html": "",
          "javascript": "if (true) {\n  let x = 5;\n}\nconsole.log(x);"
        },
        "options": {
          "A": "Globale",
          "B": "Locale à la fonction englobante",
          "C": "Locale au bloc `if`",
          "D": "Erreur"
        },
        "correct_answer": {
          "answer": ["D"]
        },
        "explanation": "Les variables déclarées avec `let` ont une portée de bloc, ce qui signifie qu'elles sont accessibles uniquement dans le bloc où elles sont déclarées. Tenter d'accéder à `x` en dehors du bloc `if` génère une erreur de référence, car `x` n'est pas défini dans ce contexte."
      },
      {
        "title": "Différence entre `var`, `let` et `const`",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 8,
        "question_type": "text_simple",
        "question_text": "Quelle déclaration est vraie concernant `var`, `let` et `const` ?",
        "options": {
          "A": "`var` a une portée de bloc, tandis que `let` et `const` ont une portée de fonction.",
          "B": "`let` permet la réaffectation mais pas la redéclaration dans la même portée, contrairement à `var`.",
          "C": "`const` permet la réaffectation des valeurs mais interdit la modification des structures d'objet.",
          "D": "`var` et `let` permettent la réaffectation, mais `const` interdit à la fois la réaffectation et la redéclaration."
        },
        "correct_answer": {
          "answer": ["B"]
        },
        "explanation": "`var` a une portée de fonction ou globale et permet la redéclaration dans la même portée. `let` a une portée de bloc, permet la réaffectation mais interdit la redéclaration dans la même portée. `const` a également une portée de bloc, permet la modification des structures d'objet mais interdit la réaffectation et la redéclaration."
      },
      {
        "title": "Types primitifs en JavaScript",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 9,
        "question_type": "text_simple",
        "question_text": "Lequel des éléments suivants n'est PAS un type primitif en JavaScript ?",
        "options": {
          "A": "Symbol",
          "B": "Undefined",
          "C": "Object",
          "D": "BigInt"
        },
        "correct_answer": {
          "answer": ["C"]
        },
        "explanation": "En JavaScript, les types primitifs incluent `undefined`, `null`, `boolean`, `number`, `string`, `symbol`, et `bigint`. L'`object` n'est pas un type primitif car il représente une collection de propriétés."
      },
      {
        "title": "Scope global et fonctionnel",
        "category": "Les Variables (types, scope, déclaration, mutabilité)",
        "question_number": 10,
        "question_type": "code_analysis",
        "question_text": "Quel est l'impact de la déclaration de `y` dans ce code ?",
        "snippet": {
          "html": "",
          "javascript": "var y = 10;\nfunction testScope() {\n  var y = 20;\n  console.log(y);\n}\ntestScope();\nconsole.log(y);"
        },
        "options": {
          "A": "Les deux `console.log` affichent `20`.",
          "B": "Le premier `console.log` affiche `20`, le second `10`.",
          "C": "Les deux `console.log` affichent `10`.",
          "D": "Le premier `console.log` affiche `10`, le second `20`."
        },
        "correct_answer": {
          "answer": ["B"]
        },
        "explanation": "La variable `y` déclarée dans `testScope` avec `var` a une portée locale à la fonction, ce qui signifie qu'elle masque la variable `y` globale à l'intérieur de `testScope`. Ainsi, le premier `console.log` dans `testScope` affiche `20`, tandis que le second `console.log`, en dehors de la fonction, accède à la variable globale `y` et affiche `10`."
      }
                                                                                                      
    ]
}